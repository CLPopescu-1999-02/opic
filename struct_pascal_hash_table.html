<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OPIC: PascalHashTable Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OPIC
   </div>
   <div id="projectbrief">Object Persistence In C</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#related">Related Functions</a>  </div>
  <div class="headertitle">
<div class="title">PascalHashTable Struct Reference<div class="ingroups"><a class="el" href="group__hash.html">Hash</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>An opaque object that manages associations of key-value pairs.  
 <a href="struct_pascal_hash_table.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:a32ef6eca381b8aac400594046230ba50"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_pascal_hash_table.html#a32ef6eca381b8aac400594046230ba50">PHNew</a> (<a class="el" href="struct_o_p_heap.html">OPHeap</a> *heap, <a class="el" href="struct_pascal_hash_table.html">PascalHashTable</a> **rhh_ref, uint64_t num_objects, double load, size_t key_inline_size, size_t valsize)</td></tr>
<tr class="memdesc:a32ef6eca381b8aac400594046230ba50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for <a class="el" href="struct_pascal_hash_table.html" title="An opaque object that manages associations of key-value pairs. ">PascalHashTable</a>.  <a href="#a32ef6eca381b8aac400594046230ba50">More...</a><br /></td></tr>
<tr class="separator:a32ef6eca381b8aac400594046230ba50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a815a6559c92eac1a870ea2cf12c8d966"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_pascal_hash_table.html#a815a6559c92eac1a870ea2cf12c8d966">PHDestroy</a> (<a class="el" href="struct_pascal_hash_table.html">PascalHashTable</a> *rhh)</td></tr>
<tr class="memdesc:a815a6559c92eac1a870ea2cf12c8d966"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor for <a class="el" href="struct_pascal_hash_table.html" title="An opaque object that manages associations of key-value pairs. ">PascalHashTable</a>.  <a href="#a815a6559c92eac1a870ea2cf12c8d966">More...</a><br /></td></tr>
<tr class="separator:a815a6559c92eac1a870ea2cf12c8d966"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88955d5f461da126751a4f6abe625042"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_pascal_hash_table.html#a88955d5f461da126751a4f6abe625042">PHInsertCustom</a> (<a class="el" href="struct_pascal_hash_table.html">PascalHashTable</a> *rhh, <a class="el" href="group__hash.html#ga677a811a212f37504245763418cae6d8">OPHash</a> hasher, void *key, size_t keysize, void *val)</td></tr>
<tr class="memdesc:a88955d5f461da126751a4f6abe625042"><td class="mdescLeft">&#160;</td><td class="mdescRight">Associates the specified key and value with custom hash function.  <a href="#a88955d5f461da126751a4f6abe625042">More...</a><br /></td></tr>
<tr class="separator:a88955d5f461da126751a4f6abe625042"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dec582cb97112a6432858eab45ada61"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_pascal_hash_table.html#a1dec582cb97112a6432858eab45ada61">PHUpsertCustom</a> (<a class="el" href="struct_pascal_hash_table.html">PascalHashTable</a> *rhh, <a class="el" href="group__hash.html#ga677a811a212f37504245763418cae6d8">OPHash</a> hasher, void *key, size_t keysize, void **val_ref, bool *is_duplicate)</td></tr>
<tr class="memdesc:a1dec582cb97112a6432858eab45ada61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update or insert depends on whether the key already exists in the hash table using custom hash function.  <a href="#a1dec582cb97112a6432858eab45ada61">More...</a><br /></td></tr>
<tr class="separator:a1dec582cb97112a6432858eab45ada61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c5c506535b3f52d7aa2ca8a88c0a655"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_pascal_hash_table.html#a6c5c506535b3f52d7aa2ca8a88c0a655">PHGetCustom</a> (<a class="el" href="struct_pascal_hash_table.html">PascalHashTable</a> *rhh, <a class="el" href="group__hash.html#ga677a811a212f37504245763418cae6d8">OPHash</a> hasher, void *key, size_t keysize)</td></tr>
<tr class="memdesc:a6c5c506535b3f52d7aa2ca8a88c0a655"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the value associated with the key and hash function. Returns NULL if the key was not found.  <a href="#a6c5c506535b3f52d7aa2ca8a88c0a655">More...</a><br /></td></tr>
<tr class="separator:a6c5c506535b3f52d7aa2ca8a88c0a655"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aede9499616b6ce9e0098c843bd3ca2f0"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_pascal_hash_table.html#aede9499616b6ce9e0098c843bd3ca2f0">PHDeleteCustom</a> (<a class="el" href="struct_pascal_hash_table.html">PascalHashTable</a> *rhh, <a class="el" href="group__hash.html#ga677a811a212f37504245763418cae6d8">OPHash</a> hasher, void *key, size_t keysize)</td></tr>
<tr class="memdesc:aede9499616b6ce9e0098c843bd3ca2f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the key-value entry with specified hash function.  <a href="#aede9499616b6ce9e0098c843bd3ca2f0">More...</a><br /></td></tr>
<tr class="separator:aede9499616b6ce9e0098c843bd3ca2f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8bf975700ce7bebfd8da6de86a12d7b"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_pascal_hash_table.html#ae8bf975700ce7bebfd8da6de86a12d7b">PHInsert</a> (<a class="el" href="struct_pascal_hash_table.html">PascalHashTable</a> *rhh, void *key, size_t keysize, void *val)</td></tr>
<tr class="memdesc:ae8bf975700ce7bebfd8da6de86a12d7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Associates the specified key and value using default hash function.  <a href="#ae8bf975700ce7bebfd8da6de86a12d7b">More...</a><br /></td></tr>
<tr class="separator:ae8bf975700ce7bebfd8da6de86a12d7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1049083cfa548fd3ad8df268b8abad8f"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_pascal_hash_table.html#a1049083cfa548fd3ad8df268b8abad8f">PHUpsert</a> (<a class="el" href="struct_pascal_hash_table.html">PascalHashTable</a> *rhh, void *key, size_t keysize, void **val_ref, bool *is_duplicate)</td></tr>
<tr class="memdesc:a1049083cfa548fd3ad8df268b8abad8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update or insert depends on whether the key already exists in the hash table.  <a href="#a1049083cfa548fd3ad8df268b8abad8f">More...</a><br /></td></tr>
<tr class="separator:a1049083cfa548fd3ad8df268b8abad8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a998e0529c0363f1a2282a32a985793da"><td class="memItemLeft" align="right" valign="top">static void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_pascal_hash_table.html#a998e0529c0363f1a2282a32a985793da">PHGet</a> (<a class="el" href="struct_pascal_hash_table.html">PascalHashTable</a> *rhh, void *key, size_t keysize)</td></tr>
<tr class="memdesc:a998e0529c0363f1a2282a32a985793da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the value associated with the key using default hash function. Returns NULL if the key was not found.  <a href="#a998e0529c0363f1a2282a32a985793da">More...</a><br /></td></tr>
<tr class="separator:a998e0529c0363f1a2282a32a985793da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9cf6bbd1bf68d68e46394478e19888b"><td class="memItemLeft" align="right" valign="top">static void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_pascal_hash_table.html#ac9cf6bbd1bf68d68e46394478e19888b">PHDelete</a> (<a class="el" href="struct_pascal_hash_table.html">PascalHashTable</a> *rhh, void *key, size_t keysize)</td></tr>
<tr class="memdesc:ac9cf6bbd1bf68d68e46394478e19888b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the key-value entry using default hash function.  <a href="#ac9cf6bbd1bf68d68e46394478e19888b">More...</a><br /></td></tr>
<tr class="separator:ac9cf6bbd1bf68d68e46394478e19888b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af33b8678e2456d2c71e291b7fbadf9e7"><td class="memItemLeft" align="right" valign="top"><a id="af33b8678e2456d2c71e291b7fbadf9e7"></a>
uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_pascal_hash_table.html#af33b8678e2456d2c71e291b7fbadf9e7">PHObjcnt</a> (<a class="el" href="struct_pascal_hash_table.html">PascalHashTable</a> *rhh)</td></tr>
<tr class="memdesc:af33b8678e2456d2c71e291b7fbadf9e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the number of objects stored in this hash table. <br /></td></tr>
<tr class="separator:af33b8678e2456d2c71e291b7fbadf9e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44b9907f3bc458d537d4565a7c5bcf07"><td class="memItemLeft" align="right" valign="top"><a id="a44b9907f3bc458d537d4565a7c5bcf07"></a>
uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_pascal_hash_table.html#a44b9907f3bc458d537d4565a7c5bcf07">PHCapacity</a> (<a class="el" href="struct_pascal_hash_table.html">PascalHashTable</a> *rhh)</td></tr>
<tr class="memdesc:a44b9907f3bc458d537d4565a7c5bcf07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the number of objects can be stored in this hash table. <br /></td></tr>
<tr class="separator:a44b9907f3bc458d537d4565a7c5bcf07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8efeb48e3d0cee60468595a22a5e9488"><td class="memItemLeft" align="right" valign="top"><a id="a8efeb48e3d0cee60468595a22a5e9488"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_pascal_hash_table.html#a8efeb48e3d0cee60468595a22a5e9488">PHKeyInlineSize</a> (<a class="el" href="struct_pascal_hash_table.html">PascalHashTable</a> *rhh)</td></tr>
<tr class="memdesc:a8efeb48e3d0cee60468595a22a5e9488"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the size of the key that can be stored inline in the hash table. If the size of the key is larger than this size, the key would not be inline but allocated somewhere in the <a class="el" href="struct_o_p_heap.html" title="Opaque object for memory allocation. ">OPHeap</a>. <br /></td></tr>
<tr class="separator:a8efeb48e3d0cee60468595a22a5e9488"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a114da62ecd749108f5c737b14fff0f6f"><td class="memItemLeft" align="right" valign="top"><a id="a114da62ecd749108f5c737b14fff0f6f"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_pascal_hash_table.html#a114da62ecd749108f5c737b14fff0f6f">PHValSize</a> (<a class="el" href="struct_pascal_hash_table.html">PascalHashTable</a> *rhh)</td></tr>
<tr class="memdesc:a114da62ecd749108f5c737b14fff0f6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the size of the value configured for this hash table. <br /></td></tr>
<tr class="separator:a114da62ecd749108f5c737b14fff0f6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af50170fb57040d215d3d2a44b3d40cad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_pascal_hash_table.html#af50170fb57040d215d3d2a44b3d40cad">PHIterate</a> (<a class="el" href="struct_pascal_hash_table.html">PascalHashTable</a> *rhh, <a class="el" href="group__hash.html#ga0d5e125f496f03099590b179c3e893b6">OPHashIterator</a> iterator, void *context)</td></tr>
<tr class="memdesc:af50170fb57040d215d3d2a44b3d40cad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterates over all key-value pairs in this hash table with user specified context.  <a href="#af50170fb57040d215d3d2a44b3d40cad">More...</a><br /></td></tr>
<tr class="separator:af50170fb57040d215d3d2a44b3d40cad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fa9e9668a9233a89251b7d58680fc5c"><td class="memItemLeft" align="right" valign="top"><a id="a2fa9e9668a9233a89251b7d58680fc5c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_pascal_hash_table.html#a2fa9e9668a9233a89251b7d58680fc5c">PHPrintStat</a> (<a class="el" href="struct_pascal_hash_table.html">PascalHashTable</a> *rhh)</td></tr>
<tr class="memdesc:a2fa9e9668a9233a89251b7d58680fc5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the accumulated count for each probing number. <br /></td></tr>
<tr class="separator:a2fa9e9668a9233a89251b7d58680fc5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>An opaque object that manages associations of key-value pairs. </p>
<p>This object is not thread safe. </p>
</div><h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a32ef6eca381b8aac400594046230ba50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32ef6eca381b8aac400594046230ba50">&#9670;&nbsp;</a></span>PHNew()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool PHNew </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_o_p_heap.html">OPHeap</a> *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_pascal_hash_table.html">PascalHashTable</a> **&#160;</td>
          <td class="paramname"><em>rhh_ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>num_objects</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>load</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>key_inline_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>valsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor for <a class="el" href="struct_pascal_hash_table.html" title="An opaque object that manages associations of key-value pairs. ">PascalHashTable</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heap</td><td><a class="el" href="struct_o_p_heap.html" title="Opaque object for memory allocation. ">OPHeap</a> instance. </td></tr>
    <tr><td class="paramname">rhh_ref</td><td>reference to the <a class="el" href="struct_pascal_hash_table.html" title="An opaque object that manages associations of key-value pairs. ">PascalHashTable</a> pointer for assignging <a class="el" href="struct_pascal_hash_table.html" title="An opaque object that manages associations of key-value pairs. ">PascalHashTable</a> instance. </td></tr>
    <tr><td class="paramname">num_objects</td><td>number of object we decided to put in. </td></tr>
    <tr><td class="paramname">load</td><td>(0.0-1.0) how full the table could be before expansion. </td></tr>
    <tr><td class="paramname">key_inline_size</td><td>Size to store the key inline. If the key size is larger than this value, the key would be copied to <a class="el" href="struct_o_p_heap.html" title="Opaque object for memory allocation. ">OPHeap</a> and get referenced by a pointer. If key_inline_size is set to 0, pointer is always used. </td></tr>
    <tr><td class="paramname">valsize</td><td>length of the value measured in bytes. This value can be zero for hashset. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true when the allocation succeeded, false otherwise. </dd></dl>

</div>
</div>
<a id="a815a6559c92eac1a870ea2cf12c8d966"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a815a6559c92eac1a870ea2cf12c8d966">&#9670;&nbsp;</a></span>PHDestroy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PHDestroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_pascal_hash_table.html">PascalHashTable</a> *&#160;</td>
          <td class="paramname"><em>rhh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor for <a class="el" href="struct_pascal_hash_table.html" title="An opaque object that manages associations of key-value pairs. ">PascalHashTable</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhh</td><td><a class="el" href="struct_pascal_hash_table.html" title="An opaque object that manages associations of key-value pairs. ">PascalHashTable</a> instance to destroy.</td></tr>
  </table>
  </dd>
</dl>
<p>All the keys managed by this instance will get dealloc as well. User need to manage the value deallocation prior calling this method. </p>

</div>
</div>
<a id="a88955d5f461da126751a4f6abe625042"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88955d5f461da126751a4f6abe625042">&#9670;&nbsp;</a></span>PHInsertCustom()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool PHInsertCustom </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_pascal_hash_table.html">PascalHashTable</a> *&#160;</td>
          <td class="paramname"><em>rhh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__hash.html#ga677a811a212f37504245763418cae6d8">OPHash</a>&#160;</td>
          <td class="paramname"><em>hasher</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>keysize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Associates the specified key and value with custom hash function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhh</td><td><a class="el" href="struct_pascal_hash_table.html" title="An opaque object that manages associations of key-value pairs. ">PascalHashTable</a> instance. </td></tr>
    <tr><td class="paramname">hasher</td><td>hash function. </td></tr>
    <tr><td class="paramname">key</td><td>pointer the the key </td></tr>
    <tr><td class="paramname">keysize</td><td>length of key data, measured in bytes. </td></tr>
    <tr><td class="paramname">val</td><td>pointer to the value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the operation succeeded, false otherwise.</dd></dl>
<p>The content pointed by key and val will be copied into the hash table. If the value size were 0, only the key get copied. When there's a key collision, the coresponding value get replaced.</p>
<p>If the inserted key-value pairs exceeded the original size user configured, the hash table will resized with a larger capacity. If the resize failed, false is returned. </p>

</div>
</div>
<a id="a1dec582cb97112a6432858eab45ada61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dec582cb97112a6432858eab45ada61">&#9670;&nbsp;</a></span>PHUpsertCustom()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool PHUpsertCustom </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_pascal_hash_table.html">PascalHashTable</a> *&#160;</td>
          <td class="paramname"><em>rhh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__hash.html#ga677a811a212f37504245763418cae6d8">OPHash</a>&#160;</td>
          <td class="paramname"><em>hasher</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>keysize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>val_ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>is_duplicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update or insert depends on whether the key already exists in the hash table using custom hash function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhh</td><td>RobinHoodHash instance. </td></tr>
    <tr><td class="paramname">hasher</td><td>hash function. </td></tr>
    <tr><td class="paramname">key</td><td>pointer to the key. </td></tr>
    <tr><td class="paramname">keysize</td><td>length of the key data, measured in bytes. </td></tr>
    <tr><td class="paramname">val_ref</td><td>reference of value pointer. </td></tr>
    <tr><td class="paramname">is_duplicate</td><td>reference of duplication boolean variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the operation succeeded, false otherwise.</dd></dl>
<p>This method does not insert the value automatically, instead it provides the pointer to the address where value can be inserted or overriden.</p>
<p>If the inserted key-value pairs exceeded the original size user configured, the hash table will resized with a larger capacity. If the resize failed, false is returned. </p>

</div>
</div>
<a id="a6c5c506535b3f52d7aa2ca8a88c0a655"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c5c506535b3f52d7aa2ca8a88c0a655">&#9670;&nbsp;</a></span>PHGetCustom()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * PHGetCustom </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_pascal_hash_table.html">PascalHashTable</a> *&#160;</td>
          <td class="paramname"><em>rhh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__hash.html#ga677a811a212f37504245763418cae6d8">OPHash</a>&#160;</td>
          <td class="paramname"><em>hasher</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>keysize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain the value associated with the key and hash function. Returns NULL if the key was not found. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhh</td><td><a class="el" href="struct_pascal_hash_table.html" title="An opaque object that manages associations of key-value pairs. ">PascalHashTable</a> instance. </td></tr>
    <tr><td class="paramname">hasher</td><td>hash function. </td></tr>
    <tr><td class="paramname">key</td><td>pointer to the key. </td></tr>
    <tr><td class="paramname">keysize</td><td>length of the key data. measured in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the value if found, NULL otherwise.</dd></dl>
<p>If the value size were set to 0, PHGetCustom would still return a pointer to where it would store the value. User can still use the returned value to exam if the key were present in the hash table. </p>

</div>
</div>
<a id="aede9499616b6ce9e0098c843bd3ca2f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aede9499616b6ce9e0098c843bd3ca2f0">&#9670;&nbsp;</a></span>PHDeleteCustom()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * PHDeleteCustom </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_pascal_hash_table.html">PascalHashTable</a> *&#160;</td>
          <td class="paramname"><em>rhh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__hash.html#ga677a811a212f37504245763418cae6d8">OPHash</a>&#160;</td>
          <td class="paramname"><em>hasher</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>keysize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes the key-value entry with specified hash function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhh</td><td><a class="el" href="struct_pascal_hash_table.html" title="An opaque object that manages associations of key-value pairs. ">PascalHashTable</a> instance. </td></tr>
    <tr><td class="paramname">hasher</td><td>hash function. </td></tr>
    <tr><td class="paramname">key</td><td>pointer to the key. </td></tr>
    <tr><td class="paramname">keysize</td><td>length of the key data, measured in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the value if found, NULL otherwise.</dd></dl>
<p>The key would get deallocated after deletion. Table will resize when many entries are deleted. </p>

</div>
</div>
<a id="ae8bf975700ce7bebfd8da6de86a12d7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8bf975700ce7bebfd8da6de86a12d7b">&#9670;&nbsp;</a></span>PHInsert()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool PHInsert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_pascal_hash_table.html">PascalHashTable</a> *&#160;</td>
          <td class="paramname"><em>rhh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>keysize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Associates the specified key and value using default hash function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhh</td><td><a class="el" href="struct_pascal_hash_table.html" title="An opaque object that manages associations of key-value pairs. ">PascalHashTable</a> instance. </td></tr>
    <tr><td class="paramname">key</td><td>pointer the the key </td></tr>
    <tr><td class="paramname">keysize</td><td>length of key data, measured in bytes. </td></tr>
    <tr><td class="paramname">val</td><td>pointer to the value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the operation succeeded, false otherwise.</dd></dl>
<p>The content pointed by key and val will be copied into the hash table. If the value size were 0, only the key get copied. When there's a key collision, the coresponding value get replaced.</p>
<p>If the inserted key-value pairs exceeded the original size user configured, the hash table will resized with a larger capacity. If the resize failed, false is returned. </p>

<p class="definition">Definition at line <a class="el" href="pascal__hash__table_8h_source.html#l00180">180</a> of file <a class="el" href="pascal__hash__table_8h_source.html">pascal_hash_table.h</a>.</p>

</div>
</div>
<a id="a1049083cfa548fd3ad8df268b8abad8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1049083cfa548fd3ad8df268b8abad8f">&#9670;&nbsp;</a></span>PHUpsert()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool PHUpsert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_pascal_hash_table.html">PascalHashTable</a> *&#160;</td>
          <td class="paramname"><em>rhh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>keysize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>val_ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>is_duplicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update or insert depends on whether the key already exists in the hash table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhh</td><td>RobinHoodHash instance. </td></tr>
    <tr><td class="paramname">key</td><td>pointer to the key. </td></tr>
    <tr><td class="paramname">keysize</td><td>length of the key data, measured in bytes. </td></tr>
    <tr><td class="paramname">val_ref</td><td>reference of value pointer. </td></tr>
    <tr><td class="paramname">is_duplicate</td><td>reference of duplication boolean variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the operation succeeded, false otherwise.</dd></dl>
<p>This method does not insert the value automatically, instead it provides the pointer to the address where value can be inserted or overriden.</p>
<p>If the inserted key-value pairs exceeded the original size user configured, the hash table will resized with a larger capacity. If the resize failed, false is returned. </p>

<p class="definition">Definition at line <a class="el" href="pascal__hash__table_8h_source.html#l00205">205</a> of file <a class="el" href="pascal__hash__table_8h_source.html">pascal_hash_table.h</a>.</p>

</div>
</div>
<a id="a998e0529c0363f1a2282a32a985793da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a998e0529c0363f1a2282a32a985793da">&#9670;&nbsp;</a></span>PHGet()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void * PHGet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_pascal_hash_table.html">PascalHashTable</a> *&#160;</td>
          <td class="paramname"><em>rhh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>keysize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain the value associated with the key using default hash function. Returns NULL if the key was not found. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhh</td><td><a class="el" href="struct_pascal_hash_table.html" title="An opaque object that manages associations of key-value pairs. ">PascalHashTable</a> instance. </td></tr>
    <tr><td class="paramname">key</td><td>pointer to the key. </td></tr>
    <tr><td class="paramname">keysize</td><td>length of the key data. measured in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the value if found, NULL otherwise.</dd></dl>
<p>If the value size were set to 0, PHGetCustom would still return a pointer to where it would store the value. User can still use the returned value to exam if the key were present in the hash table. </p>

<p class="definition">Definition at line <a class="el" href="pascal__hash__table_8h_source.html#l00227">227</a> of file <a class="el" href="pascal__hash__table_8h_source.html">pascal_hash_table.h</a>.</p>

</div>
</div>
<a id="ac9cf6bbd1bf68d68e46394478e19888b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9cf6bbd1bf68d68e46394478e19888b">&#9670;&nbsp;</a></span>PHDelete()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void * PHDelete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_pascal_hash_table.html">PascalHashTable</a> *&#160;</td>
          <td class="paramname"><em>rhh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>keysize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes the key-value entry using default hash function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhh</td><td><a class="el" href="struct_pascal_hash_table.html" title="An opaque object that manages associations of key-value pairs. ">PascalHashTable</a> instance. </td></tr>
    <tr><td class="paramname">key</td><td>pointer to the key. </td></tr>
    <tr><td class="paramname">keysize</td><td>length of the key data, measured in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the value if found, NULL otherwise.</dd></dl>
<p>The key would get deallocated after deletion. Table will resize when many entries are deleted. </p>

<p class="definition">Definition at line <a class="el" href="pascal__hash__table_8h_source.html#l00245">245</a> of file <a class="el" href="pascal__hash__table_8h_source.html">pascal_hash_table.h</a>.</p>

</div>
</div>
<a id="af50170fb57040d215d3d2a44b3d40cad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af50170fb57040d215d3d2a44b3d40cad">&#9670;&nbsp;</a></span>PHIterate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PHIterate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_pascal_hash_table.html">PascalHashTable</a> *&#160;</td>
          <td class="paramname"><em>rhh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__hash.html#ga0d5e125f496f03099590b179c3e893b6">OPHashIterator</a>&#160;</td>
          <td class="paramname"><em>iterator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterates over all key-value pairs in this hash table with user specified context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhh</td><td><a class="el" href="struct_pascal_hash_table.html" title="An opaque object that manages associations of key-value pairs. ">PascalHashTable</a> instance. </td></tr>
    <tr><td class="paramname">iterator</td><td>function pointer to user defined iterator function. </td></tr>
    <tr><td class="paramname">context</td><td>user defined context.</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><span class="comment">// Function interface matches OPHashIterator</span></div><div class="line"><span class="keywordtype">void</span> my_iterator(<span class="keywordtype">void</span>* key, <span class="keywordtype">void</span>* value,</div><div class="line">                 <span class="keywordtype">size_t</span> keysize, <span class="keywordtype">size_t</span> valsize,</div><div class="line">                 <span class="keywordtype">void</span>* context)</div><div class="line">{</div><div class="line">  <span class="comment">// Obtain the object we passed in.</span></div><div class="line">  <span class="keyword">struct </span>MyStruct* my_s = (<span class="keyword">struct </span>MyStruct*) context;</div><div class="line"></div><div class="line">  <span class="comment">// assumes both key and value were null terminated string</span></div><div class="line">  printf(<span class="stringliteral">&quot;key: %s, value: %s\n&quot;</span>, key, value);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// User defined context</span></div><div class="line"><span class="keyword">struct </span>MyStruct my_s;</div><div class="line"></div><div class="line"><span class="comment">// PHIterate takes in a PascalHashTable object, a fuction pointer</span></div><div class="line"><span class="comment">// OPHashIterator and a user defined context for iteration.</span></div><div class="line"><a class="code" href="struct_pascal_hash_table.html#af50170fb57040d215d3d2a44b3d40cad">PHIterate</a>(rhh, &amp;my_iterator, &amp;my_s);</div></div><!-- fragment --> 
</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>opic/hash/<a class="el" href="pascal__hash__table_8h_source.html">pascal_hash_table.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Aug 14 2017 08:33:27 for OPIC by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
